// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
//   sqlc-gen-java dev

package com.example.database;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import javax.sql.DataSource;

public class QueriesImpl implements Queries {

    public static final String CREATE_CITY = """
            -- name: createCity :one
            INSERT INTO city (
                name,
                slug
            ) VALUES (
                ?,
                ?
            ) RETURNING slug, name
            """;

    public static final String CREATE_VENUE = """
            -- name: createVenue :one
            INSERT INTO venue (
                slug,
                name,
                city,
                created_at,
                spotify_playlist,
                status,
                statuses,
                tags
            ) VALUES (
                ?,
                ?,
                ?,
                NOW(),
                ?,
                ?,
                ?,
                ?
            ) RETURNING id
            """;

    public static final String DELETE_VENUE = """
            -- name: deleteVenue :exec
            DELETE FROM venue
            WHERE slug = ? AND slug = ?
            """;

    public static final String GET_CITY = """
            -- name: getCity :one
            SELECT slug, name
            FROM city
            WHERE slug = ?
            """;

    public static final String GET_VENUE = """
            -- name: getVenue :one
            SELECT id, status, statuses, slug, name, city, spotify_playlist, songkick_id, tags, created_at
            FROM venue
            WHERE slug = ? AND city = ?
            """;

    public static final String LIST_CITIES = """
            -- name: listCities :many
            SELECT slug, name
            FROM city
            ORDER BY name
            """;

    public static final String LIST_VENUES = """
            -- name: listVenues :many
            SELECT id, status, statuses, slug, name, city, spotify_playlist, songkick_id, tags, created_at
            FROM venue
            WHERE city = ?
            ORDER BY name
            """;

    public static final String UPDATE_CITY_NAME = """
            -- name: updateCityName :exec
            UPDATE city
            SET name = ?
            WHERE slug = ?
            """;

    public static final String UPDATE_VENUE_NAME = """
            -- name: updateVenueName :one
            UPDATE venue
            SET name = ?
            WHERE slug = ?
            RETURNING id
            """;

    public static final String VENUE_COUNT_BY_CITY = """
            -- name: venueCountByCity :many
            SELECT
                city,
                count(*)
            FROM venue
            GROUP BY 1
            ORDER BY 1
            """;

    protected final DataSource ds;

    public QueriesImpl(final DataSource ds) {
        this.ds = ds;
    }

    //  Create a new city. The slug must be unique.
    //  This is the second line of the comment
    //  This is the third line
    @Override
    public City createCity(final CreateCityParams params) {
        City result = null;
        try (final Connection conn = ds.getConnection();
             final PreparedStatement ps = conn.prepareStatement(CREATE_CITY)) {
            ps.setString(1, params.getName());
            ps.setString(2, params.getSlug());
            try (final ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    result = new City(
                            rs.getString(1),
                            rs.getString(2));
                }
            }
        } catch (final SQLException e) {
            throw new RuntimeException(e);
        }
        return result;
    }

    @Override
    public Integer createVenue(final CreateVenueParams params) {
        Integer id = null;
        try (final Connection conn = ds.getConnection();
             final PreparedStatement ps = conn.prepareStatement(CREATE_VENUE)) {
            ps.setString(1, params.getSlug());
            ps.setString(2, params.getName());
            ps.setString(3, params.getCity());
            ps.setString(4, params.getSpotifyPlaylist());
            ps.setObject(5, params.getStatus(), java.sql.Types.OTHER);
            ps.setArray(6, conn.createArrayOf("status", params.getStatuses().toArray(new Status[0])));
            ps.setArray(7, conn.createArrayOf("text", params.getTags().toArray(new String[0])));
            try (final ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    id = rs.getInt(1);
                }
            }
        } catch (final SQLException e) {
            throw new RuntimeException(e);
        }
        return id;
    }

    @Override
    public void deleteVenue(final String slug) {
        try (final Connection conn = ds.getConnection();
             final PreparedStatement ps = conn.prepareStatement(DELETE_VENUE)) {
            ps.setString(1, slug);
            ps.execute();
        } catch (final SQLException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public City getCity(final String slug) {
        City result = null;
        try (final Connection conn = ds.getConnection();
             final PreparedStatement ps = conn.prepareStatement(GET_CITY)) {
            ps.setString(1, slug);
            try (final ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    result = new City(
                            rs.getString(1),
                            rs.getString(2));
                }
            }
        } catch (final SQLException e) {
            throw new RuntimeException(e);
        }
        return result;
    }

    @Override
    public Venue getVenue(final GetVenueParams params) {
        Venue result = null;
        try (final Connection conn = ds.getConnection();
             final PreparedStatement ps = conn.prepareStatement(GET_VENUE)) {
            ps.setString(1, params.getSlug());
            ps.setString(2, params.getCity());
            try (final ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    result = new Venue(
                            rs.getInt(1),
                            Status.valueOfLabel(rs.getString(2)),
                            java.util.Arrays.stream((String[]) rs.getArray(3).getArray()).map(label -> Status.valueOfLabel(label)).collect(java.util.stream.Collectors.toList()),
                            rs.getString(4),
                            rs.getString(5),
                            rs.getString(6),
                            rs.getString(7),
                            rs.getString(8),
                            java.util.Arrays.stream((String[]) rs.getArray(9).getArray()).collect(java.util.stream.Collectors.toList()),
                            rs.getObject(10, LocalDateTime.class));
                }
            }
        } catch (final SQLException e) {
            throw new RuntimeException(e);
        }
        return result;
    }

    @Override
    public List<City> listCities() {
        final List<City> result = new ArrayList<>();
        try (final Connection conn = ds.getConnection();
             final PreparedStatement ps = conn.prepareStatement(LIST_CITIES)) {

            try (final ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    result.add(new City(
                            rs.getString(1),
                            rs.getString(2)));
                }
            }
        } catch (final SQLException e) {
            throw new RuntimeException(e);
        }
        return result;
    }

    @Override
    public List<Venue> listVenues(final String city) {
        final List<Venue> result = new ArrayList<>();
        try (final Connection conn = ds.getConnection();
             final PreparedStatement ps = conn.prepareStatement(LIST_VENUES)) {
            ps.setString(1, city);
            try (final ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    result.add(new Venue(
                            rs.getInt(1),
                            Status.valueOfLabel(rs.getString(2)),
                            java.util.Arrays.stream((String[]) rs.getArray(3).getArray()).map(label -> Status.valueOfLabel(label)).collect(java.util.stream.Collectors.toList()),
                            rs.getString(4),
                            rs.getString(5),
                            rs.getString(6),
                            rs.getString(7),
                            rs.getString(8),
                            java.util.Arrays.stream((String[]) rs.getArray(9).getArray()).collect(java.util.stream.Collectors.toList()),
                            rs.getObject(10, LocalDateTime.class)));
                }
            }
        } catch (final SQLException e) {
            throw new RuntimeException(e);
        }
        return result;
    }

    @Override
    public void updateCityName(final UpdateCityNameParams params) {
        try (final Connection conn = ds.getConnection();
             final PreparedStatement ps = conn.prepareStatement(UPDATE_CITY_NAME)) {
            ps.setString(1, params.getName());
            ps.setString(2, params.getSlug());
            ps.execute();
        } catch (final SQLException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public Integer updateVenueName(final UpdateVenueNameParams params) {
        Integer id = null;
        try (final Connection conn = ds.getConnection();
             final PreparedStatement ps = conn.prepareStatement(UPDATE_VENUE_NAME)) {
            ps.setString(1, params.getName());
            ps.setString(2, params.getSlug());
            try (final ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    id = rs.getInt(1);
                }
            }
        } catch (final SQLException e) {
            throw new RuntimeException(e);
        }
        return id;
    }

    @Override
    public List<VenueCountByCityRow> venueCountByCity() {
        final List<VenueCountByCityRow> result = new ArrayList<>();
        try (final Connection conn = ds.getConnection();
             final PreparedStatement ps = conn.prepareStatement(VENUE_COUNT_BY_CITY)) {

            try (final ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    result.add(new VenueCountByCityRow(
                            rs.getString(1),
                            rs.getLong(2)));
                }
            }
        } catch (final SQLException e) {
            throw new RuntimeException(e);
        }
        return result;
    }
}
